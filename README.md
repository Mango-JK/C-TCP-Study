# C-TCP-Study

## Make와 Makefile

> https://bowbowbow.tistory.com/12

<br/>

**make**는 **파일 관리 유틸리티**이다.

`make`는

> 파일 간의 종속관계를 파악하여 **Makefile(기술파일)**에 적힌 대로 컴파일러에 명령하여 SHELL 명령이 순차적으로 실행될 수 있게 합니다.

### Make를 쓰는 이유

`make`를 쓰면 다음과 같은 장점이 있습니다.

> - 각 파일에 대한 반복적 명령의 자동화로 인한 시간 절약
> - 프로그램의 종속 구조를 빠르게 파악할 수 있으며 관리가 용이
> - 단순 반복 작업 및 재작성을 최소화
>
> 

### 기본적인 컴파일 과정

1. **C파일에서 object 파일 생성하기**

```c
gcc -c -o memo.o memo.c
gcc -c -o calendar.o calendar.c
gcc -c -o main.o main.c
```

각 C 파일에서 object 파일을 생성해줍니다.

여기에서 -c 옵션은 object 파일을 생성하는 옵션이고, -o 옵션은 생성될 파일 이름을 지정하는 옵션입니다.

> 여기서는 -o 옵션을 넣지 않아도 object 파일이름이 **(c파일이름).o**로 자동 생성됩니다. 하지만 실행 파일 생성시 -o 옵션을 넣지 않으면 모든 파일이 **a.out**이라는 이름을 갖게 되므로 여러 개의 실행 파일을 생성해야 할 때 효율적인 옵션입니다.

2. **각 object 파일을 묶어 컴파일을 통해 diary_exe 실행파일 생성하기**

> gcc -o diary_exe main.o memo.o calendar.o

여기서 object 파일들의 순서는 상관이 없습니다.

위 명령을 실행하면 **diary_exe** 실행파일이 생성됩니다.

3. **결과 확인하기**

바르게 생성되었다면 아래와 같이 결과가 나오는지 확인합니다.

> $./diary_exe

> 기존의 컴파일 과정이 예제에서는 귀찮지 않습니다. 모든 c파일을 각각 컴파일해도 3번만 명령해주면 되니까요. 하지만 만약 하나의 실행파일을 생성하는데 필요한 c파일이 1000개라면..? 100개의 명령어가 필요합니다. 이러한 상황을 해결해주는 것이 바로 `make`와 `makefile`입니다!

<hr/>

### make를 이용한 컴파일 과정

그럼 이제 `Makefile`을 먼저 어떻게 만드는지 알아본 후 `make` 명령으로 위의 파일들을 컴파일 해봅시다.



### Makefile의 구성

`Makefile`은 다음과 같은 구조를 가집니다.

> - 목적파일(Target) : 명령어가 수행되어 나온 결과를 저장할 파일
> - 의존성(Dependency) : 목적파일을 만들기 위해 필요한 재료
> - 명령어(Command) : 실행 되어야 할 명령어들
> - 매크로(macro) : 코드를 단순화 시키기 위한 방법
>
> 



### Makefile의 기본구조

위의 구성에서 말한 요소들은 실제 `Makefile` 코드에서 다음과 같이 배치됩니다.

<center><image src="./images/makefile.PNG"></image></center>



### Makefile 작성 규칙

> **목표파일** : 목표파일을 만드는데 필요한 **구성요소들**
>
> (tab)	목표를 달성하기 위한 명령 1
>
> (tab)	목표를 달성하기 위한 명령 2
>
> 

// 매크로 정의 : `Makefile`에 정의한 string으로 치환한다.

// 명령어의 시작은 반드시 **탭**으로 시작한다.

// Dependency가 없는 target도 사용 가능하다.



<center><image src="./images/makefile2.PNG"></image></center>

여기서 **더미타겟**은 파일을 생성하지 않는 개념적인 타겟으로

> $ make clean

라 명령하면 현재 디렉토리의 모든 **object 파일들**과 생성된 실행파일인 **diary_exe**를 rm 명령어로 제거해줍니다.



### Makefile 개선하기 : 매크로 사용

매크로는 생각보다 간단합니다. 위의 코드에서 **중복되는 파일 이름들을 특정 단어로 치환**하면 됩니다.

마치 C언어에서 **#define**을 하는 것과 비슷한 원리입니다.

<center><image src="./images/macro.PNG"></image></center>



**작성 규칙**

> - 매크로를 참조 할 때는 소괄호나 중괄호 둘러싸고 앞에 '$'를 붙인다.
> - 탭으로 시작해서는 안되고 ,:,=,#,"" 등은 매크로 이름에 사용할 수 없다.
> - 매크로는 반드시 치환될 위치보다 먼저 정의 되어야 한다.
>
> 

여기서 **-W -Wall**는 컴파일 시 컴파일이 되지 않을 정도의 오류라도 모두 출력되게 하는 옵션입니다.



> make clean
> vi Makefile //매크로 사용 예제처럼 수정
> ./diary_exe

로 전과 같은 결과가 나오는지 확인해 보세요~

여기서 더 코드를 단순화 시키기 위해서 사용자가 직접 정의하는 매크로가 아닌 미리 정의된 **내부 매크로**를 한번 사용해 보겠습니다!



### Makefile 개선하기2 : 내부 매크로 사용

<center><image src="./images/macro2.PNG"></image></center>

내부 매크로를 사용하였더니 코드가 굉장히 단순해졌습니다!

여기서 사용된 내부 매크로를 한번 살펴봅시다.

> - "$@" : 현재 타겟의 이름
> - "$^" : 현재 타겟의 종속 항목 리스트
>
> 

이를 바탕으로 위의 코드를 한번 처음부터 끝까지 해석해봅시다!

> 1. **gcc 컴파일러를 이용**
> 2. **사소한 오류까지 출력**
> 3. **최종 타겟 파일은 diary_exe**
> 4. **OBJECT로 정의할 파일들은 memo.o main.o calendar.o**
> 5. **all은 현재는 사용하지 않았지만 타겟 파일이 여러개 일때 사용됩니다.**
> 6. **타겟 파일을 만들기 위해 OBJECT 들을 사용한다.**(단 OBJECT 파일이 없다면 OBJECT 파일과 이름이 동일한 C파일을 찾아 OBJECT파일을 생성한다.)
> 7. **gcc -o diary_exe memo.o main.o calendar.o과 동일**
> 8. **더미타겟**



### 정리

이처럼 `makefile`을 생성하여  `make`명령을 사용하면 다음과 같은 장점이 있습니다.

> - 입력파일 변경 시 결과파일 자동 변경을 원할 때 지능적인 배치작업 수행
> - 일일이 gcc 명령어를 안치고도 간단하면서 용이하게 컴파일을 진행할 수 있음

<hr/>

